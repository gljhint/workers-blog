import { format } from 'date-fns';
import { BlogPost, PostMetadata, Tag, Category, CreatePostData, Admin } from './types';
import { getPublishedPosts, findPostBySlug, incrementPostViewCount, generateUniquePostSlug, createPost as createPostData, getPostsByCategorySlug, getPostsByTagSlug, type Post } from '@/models/PostModel';
import { getAllTags as getTagsFromDB } from '@/models/TagModel';
import { getAllCategories as getCategoriesFromDB, findCategoryById, findCategoriesByIds } from '@/models/CategoryModel';
import { getTagIdsByPostId, addTagsToPost, removeAllTagsFromPost, getTagIdsByPostIds } from '@/models/PostTagModel';
import { findAdminById, findAdminsByIds } from '@/models/AdminModel';
import { getKVCache, CacheKeys } from '@/lib/kvCache';

async function mapPostsToMetadata(posts: Post[]): Promise<PostMetadata[]> {
  if (!posts || posts.length === 0) return [];

  const postIds = posts.map(p => p.id);
  const authorIds = Array.from(new Set(posts.map(p => p.author_id).filter(Boolean))) as number[];
  const categoryIds = Array.from(new Set(posts.map(p => p.category_id).filter(Boolean))) as number[];

  const [tagIdMap, allTags, authors, categories] = await Promise.all([
    getTagIdsByPostIds(postIds),
    getAllTags(),
    authorIds.length ? findAdminsByIds(authorIds) : Promise.resolve([]),
    categoryIds.length ? findCategoriesByIds(categoryIds) : Promise.resolve([]),
  ]);

  const tagMap = new Map<number, Tag>();
  allTags.forEach(t => tagMap.set(t.id, t));

  const authorMap = new Map<number, Admin>();
  authors.forEach(a => authorMap.set(a.id, {
    ...a,
    display_name: a.display_name || undefined,
    bio: a.bio || undefined,
    avatar: a.avatar || undefined,
    last_login: a.last_login || undefined,
  }));

  const categoryMap = new Map<number, Category>();
  categories.forEach(c => categoryMap.set(c.id, {
    ...c,
    description: c.description || undefined,
    post_count: c.post_count || 0,
  }));

  return posts.map(post => {
    const tags: Tag[] = (tagIdMap[post.id] || [])
      .map(id => tagMap.get(id))
      .filter(Boolean) as Tag[];
    const author = post.author_id ? authorMap.get(post.author_id) : undefined;
    const category = post.category_id ? categoryMap.get(post.category_id) : undefined;
    return {
      id: post.id,
      slug: post.slug,
      title: post.title,
      description: post.description || '',
      is_published: Boolean(post.is_published),
      is_featured: Boolean(post.is_featured),
      view_count: post.view_count || 0,
      like_count: post.like_count || 0,
      comment_count: post.comment_count || 0,
      cover_image: post.cover_image || '',
      category_id: post.category_id || undefined,
      author_id: post.author_id || undefined,
      published_at: post.published_at || '',
      allow_comments: Boolean(post.allow_comments),
      created_at: post.created_at || '',
      updated_at: post.updated_at || '',
      tags,
      author,
      category,
    };
  });
}

export async function getAllPosts(): Promise<PostMetadata[]> {
  try {
    const kv = getKVCache();
    if (kv) {
      const cached = await kv.get<PostMetadata[]>(CacheKeys.POSTS_ALL);
      if (cached) return cached;
    }
    const list = await getPublishedPosts();
    const result = await mapPostsToMetadata(list as unknown as Post[]);
    if (kv) {
      await kv.set(CacheKeys.POSTS_ALL, result);
    }
    return result;
/*
    const posts = await getPublishedPosts();
    const allTags = await getAllTags();
    const result = [];
    
    for (const post of posts) {
      // é–¼æƒ§å˜²è¤°å›¬å¼¬é¥â•ƒå½¿é–»ã„¥å«­é–ï½‡ç²?      const tagIds = await getTagIdsByPostId(post.id);
      const tags: Tag[] = [];
      
      if (tagIds.length > 0) {
        tagIds.forEach(tagId => {
          const tag = allTags.find(t => t.id === tagId);
          if (tag) {
            tags.push(tag);
          }
        });
      }

      // é–¼æƒ§å˜²è¤°å›¨æ‹…å©Šå—å“é›îƒ¿ç¹†é–?      let author: Admin | undefined = undefined;
      if (post.author_id) {
        const authorData = await findAdminById(post.author_id);
        author = authorData ? {
          ...authorData,
          display_name: authorData.display_name || undefined,
          bio: authorData.bio || undefined,
          avatar: authorData.avatar || undefined,
          created_at: authorData.created_at || '',
          updated_at: authorData.updated_at || '',
          is_active: Boolean(authorData.is_active),
          last_login: authorData.last_login || undefined
        } : undefined;
      }

      // é–¼æƒ§å˜²è¤°å›¬å´šé¡æ¬’î¦å¨£å›£å‰æµ?
      let category: Category | undefined = undefined;
      if (post.category_id) {
        const categoryData = await findCategoryById(post.category_id);
        category = categoryData ? {
          ...categoryData,
          description: categoryData.description || undefined,
          created_at: categoryData.created_at || '',
          updated_at: categoryData.updated_at || '',
          post_count: categoryData.post_count || 0
        } : undefined;
      }

      result.push({
        id: post.id,
        slug: post.slug,
        title: post.title,
        description: post.description || '',
        is_published: Boolean(post.is_published),
        is_featured: Boolean(post.is_featured),
        view_count: post.view_count || 0,
        like_count: post.like_count || 0,
        comment_count: post.comment_count || 0,
        cover_image: post.cover_image || '',
        category_id: post.category_id || undefined,
        author_id: post.author_id || undefined,
        published_at: post.published_at || '',
        allow_comments: Boolean(post.allow_comments),
        created_at: post.created_at || '',
        updated_at: post.updated_at || '',
        tags,
        author,
        category
      });
    }
    if (kv) {
      await kv.set(CacheKeys.POSTS_ALL, result);
    }
    return result;
  } catch (error) {
    console.error('Error fetching posts:', error);
    return [];
  }
}

export async function getPostBySlug(slug: string, incrementView = false): Promise<BlogPost | null> {
  try {
*/
    const post = await findPostBySlug(slug);
    
    if (!post || !post.is_published) {
      return null;
    }

    // å©µâ€³å€¹éå¤æ£éˆ§î„‚æ†°æµ£å‰²æ»é–¸æ—‚å§µç»è¤æ†´é«ãƒ¥æ«¤é–¿æ¶˜è‹¯é¨îˆœæ‹«éî…æšå©¢Ñ…å›æ¿®ç‚²Ã¹è¹‡æ°¼æ½”é—æ’ç¹’å¨ˆæˆ¦å¼¬ç‘™å‹­ã€?
    if (incrementView) {
      await incrementPostViewCount(slug);
    }

    // é–¼æƒ§å˜²è¤°å›¬å¼¬é¥â•ƒå½¿é–»ã„¥å«­é–ï½‡ç²?    const tagIds = await getTagIdsByPostId(post.id);
    const tags: Tag[] = [];
    
    if (tagIds.length > 0) {
      const allTags = await getAllTags();
      tagIds.forEach(tagId => {
        const tag = allTags.find(t => t.id === tagId);
        if (tag) {
          tags.push(tag);
        }
      });
    }

    // é–¼æƒ§å˜²è¤°å›¨æ‹…å©Šå—å“é›îƒ¿ç¹†é–?    let author: Admin | undefined = undefined;
    if (post.author_id) {
      const authorData = await findAdminById(post.author_id);
      author = authorData ? {
        ...authorData,
        display_name: authorData.display_name || undefined,
        bio: authorData.bio || undefined,
        avatar: authorData.avatar || undefined,
        created_at: authorData.created_at || '',
        updated_at: authorData.updated_at || '',
        is_active: Boolean(authorData.is_active),
        last_login: authorData.last_login || undefined
      } : undefined;
    }

    // é–¼æƒ§å˜²è¤°å›¬å´šé¡æ¬’î¦å¨£å›£å‰æµ?
    let category: Category | undefined = undefined;
    if (post.category_id) {
      const categoryData = await findCategoryById(post.category_id);
      category = categoryData ? {
        ...categoryData,
        description: categoryData.description || undefined,
        created_at: categoryData.created_at || '',
        updated_at: categoryData.updated_at || '',
        post_count: categoryData.post_count || 0
      } : undefined;
    }

    return {
      id: post.id,
      slug: post.slug,
      title: post.title,
      description: post.description || '',
      content: post.content,
      is_published: Boolean(post.is_published),
      is_featured: Boolean(post.is_featured),
      view_count: post.view_count || 0,
      like_count: post.like_count || 0,
      comment_count: post.comment_count || 0,
      cover_image: post.cover_image || '',
      category_id: post.category_id || undefined,
      author_id: post.author_id || undefined,
      published_at: post.published_at || '',
      allow_comments: Boolean(post.allow_comments),
      created_at: post.created_at || '',
      updated_at: post.updated_at || '',
      tags,
      author,
      category
    };
  } catch (error) {
    console.error(`Error fetching post ${slug}:`, error);
    return null;
  }
}

export async function getPostsByTag(tagSlug: string): Promise<PostMetadata[]> {
  try {
    const list = await getPostsByTagSlug(tagSlug);
    return await mapPostsToMetadata(list as unknown as Post[]);
    const posts = await getPostsByTagSlug(tagSlug);
    const result = [];
    
    for (const post of posts) {
      // é–¼æƒ§å˜²è¤°å›¬å¼¬é¥â•ƒå½¿é–»ã„¥å«­é–ï½‡ç²?      const tagIds = await getTagIdsByPostId(post.id);
      const tags: Tag[] = [];
      
      if (tagIds.length > 0) {
        const allTags = await getAllTags();
        tagIds.forEach(tagId => {
          const tag = allTags.find(t => t.id === tagId);
          if (tag) {
            tags.push(tag);
          }
        });
      }

      // é–¼æƒ§å˜²è¤°å›¨æ‹…å©Šå—å“é›îƒ¿ç¹†é–?      let author: Admin | undefined = undefined;
      if (post.author_id) {
        const authorData = await findAdminById(post.author_id);
        author = authorData ? {
          ...authorData,
          display_name: authorData.display_name || undefined,
          bio: authorData.bio || undefined,
          avatar: authorData.avatar || undefined,
          created_at: authorData.created_at || '',
          updated_at: authorData.updated_at || '',
          is_active: Boolean(authorData.is_active),
          last_login: authorData.last_login || undefined
        } : undefined;
      }

      // é–¼æƒ§å˜²è¤°å›¬å´šé¡æ¬’î¦å¨£å›£å‰æµ?
      let category: Category | undefined = undefined;
      if (post.category_id) {
        const categoryData = await findCategoryById(post.category_id);
        category = categoryData ? {
          ...categoryData,
          description: categoryData.description || undefined,
          created_at: categoryData.created_at || '',
          updated_at: categoryData.updated_at || '',
          post_count: categoryData.post_count || 0
        } : undefined;
      }

      result.push({
        id: post.id,
        slug: post.slug,
        title: post.title,
        description: post.description || '',
        is_published: Boolean(post.is_published),
        is_featured: Boolean(post.is_featured),
        view_count: post.view_count || 0,
        like_count: post.like_count || 0,
        comment_count: post.comment_count || 0,
        cover_image: post.cover_image || '',
        category_id: post.category_id || undefined,
        author_id: post.author_id || undefined,
        published_at: post.published_at || '',
        allow_comments: Boolean(post.allow_comments),
        created_at: post.created_at || '',
        updated_at: post.updated_at || '',
        tags,
        author,
        category
      });
    }
    
    return result;
  } catch (error) {
    console.error('Error fetching posts by tag:', error);
    return [];
  }
}

export async function getAllTags(): Promise<Tag[]> {
  try {
    const kv = getKVCache();
    if (kv) {
      const cached = await kv.get<Tag[]>(CacheKeys.TAGS);
      if (cached) return cached;
    }

    const tags = await getTagsFromDB();
    const mapped = tags.map(tag => ({
      id: tag.id,
      name: tag.name,
      slug: tag.slug,
      post_count: tag.post_count || 0,
      created_at: tag.created_at || '',
      updated_at: tag.updated_at || ''
    }));

    if (kv) {
      await kv.set(CacheKeys.TAGS, mapped);
    }

    return mapped;
  } catch (error) {
    console.error('Error fetching tags:', error);
    return [];
  }
}

export async function getAllCategories(): Promise<Category[]> {
  try {
    const kv = getKVCache();
    if (kv) {
      const cached = await kv.get<Category[]>(CacheKeys.CATEGORIES);
      if (cached) return cached;
    }

    const categories = await getCategoriesFromDB();
    const mapped = categories.map(category => ({
      id: category.id,
      name: category.name,
      slug: category.slug,
      description: category.description || '',
      post_count: category.post_count || 0,
      created_at: category.created_at || '',
      updated_at: category.updated_at || ''
    }));

    if (kv) {
      await kv.set(CacheKeys.CATEGORIES, mapped);
    }

    return mapped;
  } catch (error) {
    console.error('Error fetching categories:', error);
    return [];
  }
}

export async function getPostsByCategory(categorySlug: string): Promise<PostMetadata[]> {
  try {
    const list = await getPostsByCategorySlug(categorySlug);
    return await mapPostsToMetadata(list as unknown as Post[]);
    const posts = await getPostsByCategorySlug(categorySlug);
    const result = [];
    
    for (const post of posts) {
      // é–¼æƒ§å˜²è¤°å›¬å¼¬é¥â•ƒå½¿é–»ã„¥å«­é–ï½‡ç²?      const tagIds = await getTagIdsByPostId(post.id);
      const tags: Tag[] = [];
      
      if (tagIds.length > 0) {
        const allTags = await getAllTags();
        tagIds.forEach(tagId => {
          const tag = allTags.find(t => t.id === tagId);
          if (tag) {
            tags.push(tag);
          }
        });
      }

      // é–¼æƒ§å˜²è¤°å›¨æ‹…å©Šå—å“é›îƒ¿ç¹†é–?      let author: Admin | undefined = undefined;
      if (post.author_id) {
        const authorData = await findAdminById(post.author_id);
        author = authorData ? {
          ...authorData,
          display_name: authorData.display_name || undefined,
          bio: authorData.bio || undefined,
          avatar: authorData.avatar || undefined,
          created_at: authorData.created_at || '',
          updated_at: authorData.updated_at || '',
          is_active: Boolean(authorData.is_active),
          last_login: authorData.last_login || undefined
        } : undefined;
      }

      // é–¼æƒ§å˜²è¤°å›¬å´šé¡æ¬’î¦å¨£å›£å‰æµ?
      let category: Category | undefined = undefined;
      if (post.category_id) {
        const categoryData = await findCategoryById(post.category_id);
        category = categoryData ? {
          ...categoryData,
          description: categoryData.description || undefined,
          created_at: categoryData.created_at || '',
          updated_at: categoryData.updated_at || '',
          post_count: categoryData.post_count || 0
        } : undefined;
      }

      result.push({
        id: post.id,
        slug: post.slug,
        title: post.title,
        description: post.description || '',
        is_published: Boolean(post.is_published),
        is_featured: Boolean(post.is_featured),
        view_count: post.view_count || 0,
        like_count: post.like_count || 0,
        comment_count: post.comment_count || 0,
        cover_image: post.cover_image || '',
        category_id: post.category_id || undefined,
        author_id: post.author_id || undefined,
        published_at: post.published_at || '',
        allow_comments: Boolean(post.allow_comments),
        created_at: post.created_at || '',
        updated_at: post.updated_at || '',
        tags,
        author,
        category
      });
    }
    
    return result;
  } catch (error) {
    console.error('Error fetching posts by category:', error);
    return [];
  }
}

export async function createPost(data: CreatePostData): Promise<BlogPost | null> {
  try {
    const slug = await generateUniquePostSlug(data.title);
    
    const postData = await createPostData({
      title: data.title,
      slug,
      content: data.content || '',
      description: data.description,
      is_published: data.is_published || false,
      is_featured: data.is_featured || false,
      cover_image: data.cover_image,
      category_id: data.category_id,
      author_id: data.author_id,
      allow_comments: data.allow_comments !== false
    });

    if (!postData) return null;

    return await getPostBySlug(slug);
  } catch (error) {
    console.error('Error creating post:', error);
    return null;
  }
}

export function formatDate(dateString: string): string {
  // å¤„ç†ä»æ•°æ®åº“è¿”å›çš?SQL å‡½æ•°å ä½å­—ç¬¦ä¸?
  if (!dateString || dateString === "datetime('now')" || dateString.trim() === '') {
    return format(new Date(), 'yyyy-MM-dd');
  }
  const date = new Date(dateString);
  if (isNaN(date.getTime())) {
    console.warn('Invalid date string:', dateString);
    return format(new Date(), 'yyyy-MM-dd');
  }
  return format(date, 'yyyy-MM-dd');
}
export function generateSlug(title: string): string {
  return title.toLowerCase()
    .replace(/[^\w\s-]/g, '')
    .replace(/\s+/g, '-')
    .trim();
}

